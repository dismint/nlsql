[
  {
    "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
    "sql": "SELECT * FROM (SELECT OFFER_DEPT_NAME AS \"DEPT\", OFFER_SCHOOL_NAME AS \"SCHOOL\", COURSE_NUMBER AS COURSE_NR, SUBJECT_TITLE AS TITLE, SUM(NUM_ENROLLED_STUDENTS) AS TYPE, lso.TERM_CODE, COUNT(DISTINCT CATALOG_ISBN) AS OWNERSHIP FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY GROUP BY OFFER_DEPT_NAME, OFFER_SCHOOL_NAME, COURSE_NUMBER, SUBJECT_TITLE, lso.TERM_CODE ORDER BY OFFER_DEPT_NAME, COURSE_NUMBER, SUBJECT_TITLE, lso.TERM_CODE) UNION ALL SELECT 'TOTAL:', NULL, NULL, NULL, SUM(NUM_ENROLLED_STUDENTS), NULL, COUNT(DISTINCT CATALOG_ISBN) FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERM_PARAMETER acp ON lso.TERM_CODE = acp.TERM_CODE WHERE IS_CURRENT_TERM = 'Y'",
    "db_id": "dw"
  },
  {
    "question": "For each mailing list that involves subscribers that work in departments that have names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
    "sql": "SELECT CASE WHEN LAG(OWNERSHIP_TYPE) OVER (ORDER BY OWNERSHIP_TYPE_gr DESC, ML) = OWNERSHIP_TYPE THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP_TYPE, ML, nr_owner, nr_member FROM (SELECT CASE WHEN GROUPING(OWNER_TYPE) = 1 AND GROUPING(MOIRA_LIST_NAME) = 0 THEN OWNER_TYPE || '1' ELSE OWNER_TYPE || '2' END AS OWNERSHIP_TYPE_gr, CASE WHEN GROUPING(MOIRA_LIST_NAME) = 1 AND GROUPING(OWNER_TYPE) = 0 THEN 'SUBTOTAL' WHEN GROUPING(MOIRA_LIST_NAME) = 1 AND GROUPING(OWNER_TYPE) = 1 THEN 'TOTAL' ELSE OWNER_TYPE END AS OWNERSHIP_TYPE, MOIRA_LIST_NAME AS ML, COUNT(DISTINCT OWNER) AS nr_owner, COUNT(DISTINCT MOIRA_LIST_MEMBER_MIT_ID) AS nr_member FROM MOIRA_LIST_OWNER mlo JOIN MOIRA_LIST_DETAIL mld ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN MOIRA_LIST ml ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ON MIT_ID = MOIRA_LIST_MEMBER_MIT_ID WHERE department_name LIKE 'Computer Science%' GROUP BY ROLLUP(OWNER_TYPE, MOIRA_LIST_NAME) ORDER BY OWNER_TYPE DESC, MOIRA_LIST_NAME) tbltmp",
    "db_id": "dw"
  },
  {
    "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
    "sql": "WITH SponsorAndStartTime AS (\n    SELECT\n        isc.IAP_CATEGORY_NAME,\n        isp.SPONSOR_NAME,\n        iss.SESSION_START_TIME,\n        COUNT(isp.SPONSOR_NAME) AS sponsor_count,\n        COUNT(iss.SESSION_START_TIME) AS start_time_count\n    FROM \n        IAP_SUBJECT_CATEGORY isc\n    JOIN \n        IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY\n    LEFT JOIN \n        IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY\n    LEFT JOIN \n        IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY\n    GROUP BY \n        isc.IAP_CATEGORY_NAME, isp.SPONSOR_NAME, iss.SESSION_START_TIME\n),\nMostCommonDetails AS (\n    SELECT\n        IAP_CATEGORY_NAME,\n        MAX(SPONSOR_NAME) KEEP (DENSE_RANK FIRST ORDER BY sponsor_count DESC) AS most_common_sponsor,\n        MAX(SESSION_START_TIME) KEEP (DENSE_RANK FIRST ORDER BY start_time_count DESC) AS most_common_start_time\n    FROM \n        SponsorAndStartTime\n    GROUP BY \n        IAP_CATEGORY_NAME\n),\nCategorySummary AS (\n    SELECT \n        isc.IAP_CATEGORY_NAME AS TYPE,\n        COUNT(DISTINCT isd.IAP_SUBJECT_SESSION_KEY) AS nr_sessions,\n        TO_CHAR(SUM(isd.MAX_ENROLLMENT), '999,999,999,999') AS total_attend,\n        MIN(isd.TERM_CODE) AS first_active_year,\n        MAX(isd.TERM_CODE) AS last_active_year,\n        mcd.most_common_sponsor,\n        mcd.most_common_start_time\n    FROM \n        IAP_SUBJECT_CATEGORY isc\n    JOIN \n        IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY\n    LEFT JOIN \n        MostCommonDetails mcd ON isc.IAP_CATEGORY_NAME = mcd.IAP_CATEGORY_NAME\n    GROUP BY \n        isc.IAP_CATEGORY_NAME, mcd.most_common_sponsor, mcd.most_common_start_time\n)\nSELECT \n    TYPE,\n    nr_sessions,\n    total_attend,\n    first_active_year || '-' || last_active_year AS active_years,\n    most_common_sponsor,\n    most_common_start_time\nFROM \n    CategorySummary\nUNION ALL\nSELECT \n    'TOTAL',\n    COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY),\n    TO_CHAR(SUM(MAX_ENROLLMENT), '999,999,999,999'),\n    NULL,\n    NULL,\n    NULL\nFROM \n    IAP_SUBJECT_DETAIL\nORDER BY \n    TYPE;\n",
    "db_id": "dw"
  },
  {
    "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
    "sql": "SELECT * FROM (SELECT CASE WHEN BUILDING_TYPE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE BUILDING_TYPE END AS TYPE, COUNT(DISTINCT NVL(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS,count(distinct MIT_ID),count(distinct BUILDINGS.BUILDING_STREET_ADDRESS), count(distinct fac_building_address.CITY), count(distinct fac_building_address.STATE), count(distinct fac_building_address.POSTAL_CODE),SUM(FLOOR.EXT_GROSS_AREA)/count(distinct MIT_ID) FROM WAREUSER.FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY  JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET' GROUP BY BUILDING_TYPE ORDER BY BUILDING_TYPE ASC) UNION ALL SELECT 'TOTAL', COUNT(DISTINCT NVL(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)), count(distinct MIT_ID), count(distinct BUILDINGS.BUILDING_STREET_ADDRESS), count(distinct fac_building_address.CITY), count(distinct fac_building_address.STATE), count(distinct fac_building_address.POSTAL_CODE),SUM(FLOOR.EXT_GROSS_AREA)/count(distinct MIT_ID) FROM WAREUSER.FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET'",
    "db_id": "dw"
  },
  {
    "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the sapce. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmuse, rmcnt, area, area_avg FROM (SELECT CASE WHEN GROUPING(ACCESS_LEVEL) = 1 THEN 'TOTAL' ELSE ACCESS_LEVEL END AS assign, CASE WHEN GROUPING(su2.SPACE_USAGE) = 1 AND GROUPING(ACCESS_LEVEL) = 0 THEN 'SUBTOTAL' ELSE su2.SPACE_USAGE END AS muse, CASE WHEN GROUPING(su2.SPACE_USAGE) = 1 AND GROUPING(ACCESS_LEVEL) = 0 THEN 'zzz' ELSE su2.SPACE_USAGE END AS muse_sort, CASE WHEN GROUPING(DLC_NAME) = 1 AND GROUPING(su2.SPACE_USAGE) = 0 THEN 'SUBTOTAL' ELSE DLC_NAME END AS rmuse, CASE WHEN GROUPING(DLC_NAME) = 1 AND GROUPING(su2.SPACE_USAGE) = 0 THEN 'zzz' ELSE DLC_NAME END AS rmuse_sort, TO_CHAR(COUNT(DISTINCT SPACE_UNIT), '999,999,999') AS rmcnt,TO_CHAR(SUM(ROOM_SQUARE_FOOTAGE), '999,999,999') AS area, TO_CHAR(AVG(ROOM_SQUARE_FOOTAGE), '999,999,999') AS area_avg FROM SPACE_UNIT su JOIN (SELECT * FROM SPACE_DETAIL WHERE BUILDING_KEY = '32') sd ON sd.SPACE_UNIT_KEY=su.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY=sd.SPACE_USAGE_KEY JOIN (SELECT * FROM WAREUSER.ZPM_ROOMS_LOAD where BUILDING_COMPONENT='32') zrl ON zrl.SPACE_UNIT_CODE = su.SPACE_UNIT_CODE JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY WHERE su2.SPACE_USAGE NOT LIKE '%STORAGE%' GROUP BY ROLLUP(ACCESS_LEVEL, su2.SPACE_USAGE, DLC_NAME) ORDER BY assign, muse_sort, rmuse_sort) tbltmp",
    "db_id": "dw"
  },
  {
    "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude the  organizations: '139',and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
    "sql": "SELECT SUBSTR(organization_sort, 5, 2) AS breakgrp, organization_id, organization_name, CASE WHEN organization_level = 4 THEN '    ' || organization_name WHEN organization_level = 5 THEN '          ' || organization_name WHEN organization_level = 6 THEN '                ' || organization_name ELSE organization_name END AS formatted_name, CASE WHEN EMERITUS_STATUS = 'Emeritus' THEN 'EMERITUS' ELSE 'NON-EMERITUS' END AS assign, organization_number, organization_level, (SELECT COUNT(DISTINCT hfr2.MIT_ID) AS employer_count FROM HR_FACULTY_ROSTER hfr2 WHERE hfr2.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE) , HIERARCHY_TYPE, organization_sort FROM FCLT_ORGANIZATION JOIN MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY JOIN HR_ORG_UNIT hou on hou.DLC_KEY=FCLT_ORGANIZATION.DLC_KEY JOIN HR_FACULTY_ROSTER hfr ON hfr.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE WHERE organization_level IN ('3', '4', '5', '6') AND organization_id NOT IN ('139', '250')  ORDER BY HIERARCHY_TYPE",
    "db_id": "dw"
  },
  {
    "question": "For each course, list its title, name of the building of the course location, duration in terms of days, and a running average of the duration using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
    "sql": "select distinct ccso.subject_title, building_name, ccso.duration, avg(duration) over (partition by ccso.academic_year order by ccso.term_start_date rows between 2 preceding and 2 following) from (select distinct subject_title, term_start_date, term_end_date-term_start_date as duration, cis.academic_year, meet_place from academic_terms join COURSE_CATALOG_SUBJECT_OFFERED cis on cis.effective_term_code=academic_terms.term_code) ccso JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY",
    "db_id": "dw"
  },
  {
    "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
    "sql": "SELECT \r\n    ccso.subject_title,\r\n    fb.BUILDING_NAME_LONG AS building_name,\r\n    at.TERM_START_DATE AS term_start_date,\r\n    lag(ccso.subject_title) OVER (\r\n        ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC\r\n    ) AS previous_subject_title,\r\n    lead(ccso.subject_title) OVER (\r\n        ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC\r\n    ) AS next_subject_title,\r\n    fb.ACCESS_LEVEL_NAME AS access_level,\r\n    fr.AREA AS room_assignable_area\r\nFROM (\r\n    SELECT DISTINCT \r\n        subject_id, \r\n        subject_title, \r\n        effective_term_code, \r\n        meet_place \r\n    FROM COURSE_CATALOG_SUBJECT_OFFERED\r\n) ccso\r\nJOIN ACADEMIC_TERMS at ON at.TERM_CODE = ccso.effective_term_code\r\nJOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY\r\nJOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\r\nORDER BY \r\n    at.TERM_START_DATE ASC, \r\n    ccso.subject_title ASC;\r",
    "db_id": "dw"
  },
  {
    "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, that took place in the same year as the course and before (partitioned by academic year and sorted in the ascending order of course start date).",
    "sql": "select distinct subject_title, building_name, count(ccso.subject_id) over (partition by ccso.academic_year order by term_start_date asc range between unbounded preceding and current row) from COURSE_CATALOG_SUBJECT_OFFERED ccso join academic_terms on ccso.effective_term_code =academic_terms.term_code  JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY",
    "db_id": "dw"
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses, the maximum units, average duration, and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) = assign THEN NULL ELSE assign END AS assign, CLUSTER_TYPE, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, CLUSTER_TYPE, max(term_end_date-term_start_date) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(term_end_date-term_start_date) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE WHERE CLUSTER_TYPE IS  NOT NULL and ss.department_name in ('Chemistry', 'Biology') GROUP BY ROLLUP(IS_CURRENT_TERM, CLUSTER_TYPE) ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) tbltmp",
    "db_id": "dw"
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses, the maximum units, average duration, and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) = assign THEN NULL ELSE assign END AS assign, OFFER_DEPT_NAME, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, OFFER_DEPT_NAME, max(term_end_date-term_start_date) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(term_end_date-term_start_date) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE JOIN SUBJECT_OFFERED so ON so.SUBJECT_ID = ss.SUBJECT_ID where so.offer_dept_name in ('Chemistry', 'Biology') GROUP BY ROLLUP(IS_CURRENT_TERM, OFFER_DEPT_NAME) ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) tbltmp",
    "db_id": "dw"
  },
  {
    "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "sql": "SELECT CASE WHEN LAG(dept) OVER (ORDER BY dept, dept_sort, master) = dept THEN NULL ELSE dept END AS dept, CASE WHEN master = 'zzz' THEN NULL ELSE master END AS master, subcnt, totalprice, matcnt FROM ( SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE OFFER_DEPT_NAME END AS dept_sort, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'TOTAL' ELSE OFFER_DEPT_NAME END AS dept, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE MASTER_COURSE_NUMBER END AS master, TO_CHAR(COUNT(distinct tso.SUBJECT_ID), '999,999,999') AS subcnt, TO_CHAR(SUM(NEW_SHELF_PRICE), '999,999,999') AS totalprice, TO_CHAR(COUNT(DISTINCT tm.ISBN), '999,999,999') AS matcnt FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td. TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY GROUP BY ROLLUP(OFFER_DEPT_NAME, MASTER_COURSE_NUMBER) ORDER BY dept_sort, master ) tbltmp",
    "db_id": "dw"
  },
  {
    "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
    "sql": "SELECT \r\n    CASE \r\n        WHEN LAG(term) OVER (ORDER BY term_sort, term, dept_sort) = term THEN NULL \r\n        ELSE term \r\n    END AS term,\r\n    dept,\r\n    subcnt,\r\n  avgeqisub,\r\n    sd.SCHOOL_NAME AS school_name,\r\n  ad.DEPARTMENT_PHONE_NUMBER AS department_phone\r\nFROM (\r\n    SELECT \r\n        CASE \r\n            WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz'\r\n            ELSE TERM_CODE \r\n        END AS term_sort,\r\n        CASE \r\n            WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL'\r\n            WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'TOTAL'\r\n            ELSE TERM_CODE \r\n        END AS term,\r\n        CASE \r\n            WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz'\r\n            ELSE DEPARTMENT_NAME \r\n        END AS dept_sort,\r\n        DEPARTMENT_NAME AS dept,\r\n        COUNT(DISTINCT SUBJECT_ID) AS subcnt,\r\n        MIN(MEET_TIME) AS mintime,\r\n        AVG(CASE \r\n                WHEN equivalent_subjects IS NULL THEN 0 \r\n                ELSE 1 + LENGTH(equivalent_subjects) - LENGTH(REPLACE(equivalent_subjects, ',', '')) \r\n            END) AS avgeqisub\r\n    FROM \r\n        COURSE_CATALOG_SUBJECT_OFFERED\r\n    GROUP BY \r\n        ROLLUP(TERM_CODE, DEPARTMENT_NAME)\r\n) tbltmp\r\nLEFT JOIN SIS_DEPARTMENT sd ON tbltmp.dept = sd.DEPARTMENT_NAME\r\nLEFT JOIN SIS_ADMIN_DEPARTMENT ad ON sd.DEPARTMENT_CODE = ad.SIS_ADMIN_DEPARTMENT_CODE\r\nORDER BY \r\n    term_sort, dept_sort;\r\n",
    "db_id": "dw"
  },
  {
    "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time, and average IAP session time. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, muse, session_count, total_time, avg_time FROM (SELECT CASE WHEN  GROUPING(IAP_CATEGORY_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(IAP_CATEGORY_NAME) = 1 AND  GROUPING(IAP_CATEGORY_NAME) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END END AS assign, IAP_CATEGORY_NAME AS muse, COUNT(SESSION_DATE) AS session_count, SUM(COALESCE(TO_DATE(SESSION_END_TIME, 'HHMIPM') - TO_DATE(SESSION_START_TIME, 'HHMIPM'), 0)) AS total_time, AVG(COALESCE(TO_DATE(SESSION_END_TIME, 'HHMIPM') - TO_DATE(SESSION_START_TIME, 'HHMIPM'), 0)) AS avg_time FROM IAP_SUBJECT_DETAIL ss JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ss.TERM_CODE JOIN IAP_SUBJECT_SESSION iss ON iss.IAP_SUBJECT_SESSION_KEY =ss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_CATEGORY isc ON isc.IAP_SUBJECT_CATEGORY_KEY=ss.IAP_SUBJECT_CATEGORY_KEY GROUP BY ROLLUP(IS_CURRENT_TERM, IAP_CATEGORY_NAME) ORDER BY assign, muse) tbltmp",
    "db_id": "dw"
  }
]